<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PGN Trainer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
  <script src="/chess/js/trainer-tracking.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      background: #f4f4f4;
    }
    #board {
      width: 400px;
      margin-bottom: 20px;
    }
    textarea {
      width: 100%;
      height: 100px;
    }
    .pgn-label.small {
  font-size: 0.85em;
  color: #666;
  margin-bottom: 4px;
}

  </style>
</head>
<body>

  <h1>PGN Trainer (TSR Style)</h1>
  <button onclick="resetStats()" style="
  position: absolute;
  top: 20px;
  right: 20px;
  background-color: #e74c3c;
  color: white;
  border: none;
  padding: 8px 14px;
  font-weight: bold;
  border-radius: 4px;
  cursor: pointer;
">
  Reset Stats
</button>

<div style="position: absolute; top: 20px; right: 140px; display: flex; gap: 10px;">
    <button onclick="downloadStats()" style="background-color: #3498db; color: white; padding: 6px 10px; border: none; border-radius: 4px; cursor: pointer;">
      ‚¨áÔ∏è Download Stats
    </button>
  
    <label style="background-color: #2ecc71; color: white; padding: 6px 10px; border-radius: 4px; cursor: pointer;">
      ‚¨ÜÔ∏è Upload Stats
      <input type="file" accept=".json" onchange="uploadStats(event)" style="display: none;">
    </label>
  </div>
  


  <label for="color-select">Train as:</label>
  <select id="color-select">
    <option value="white" selected>White</option>
    <option value="black">Black</option>
  </select>
  <br><br>

  <div id="board"></div>
  <div style="display: flex; gap: 20px; margin-top: 10px;">
    <div id="stats-prev" style="flex: 1; background:#f9f9f9;padding:10px;border:1px solid #ccc;"></div>
    <div id="stats-box" style="flex: 1; background:#fff;padding:10px;border:1px solid #ccc;"></div>
  </div>
  
  <p><strong>Status:</strong> <span id="status">Paste a PGN and click Start</span></p>

  <textarea id="pgn-input" placeholder="Paste PGN here..."></textarea>
  <br><br>
  <button onclick="startTrainer()">Start Trainer</button>

  <script>
    function resetStats() {
    if (!pgnId || !userColor) {
        alert("Start training first to reset stats.");
        return;
    }

    const key = `pgn-trainer:${userColor}:${pgnId}`;
    localStorage.removeItem(key);
    alert(`Stats for ${userColor.toUpperCase()} on current PGN have been reset.`);

    // Clear both stat boxes
    document.getElementById('stats-box').innerHTML = "";
    document.getElementById('stats-prev').innerHTML = "";
    }


    fetch('/chess/white_0.55_1000-1._e4_e5_2._d4_exd4_3._c3_dxc3_4._Bc4_cxb2_5._Bxb2-rep.pgn')
      .then(response => response.text())
      .then(data => {
        document.getElementById('pgn-input').value = data;
      })
      .catch(error => {
        console.error("Couldn't load PGN file:", error);
      });
  </script>
  

  <script>
    let board = null;
    let game = new Chess();
    let pgnMoves = [];
    let currentIndex = 0;
    let moveStartTime = Date.now();
    let lastQuestionKey = null;
    let pgnId = "";
    let currentPgnSoFar = "";
    let userColor = "white";

    function startTrainer() {
        const pgn = document.getElementById('pgn-input').value;
        userColor = document.getElementById('color-select').value;
        pgnId = getPGNId(pgn);

        game.reset();
        if (!game.load_pgn(pgn)) {
            updateStatus("‚ö†Ô∏è Invalid PGN. Try again.");
            return;
        }

        pgnMoves = game.history();
        game.reset();
        currentIndex = 0;

        board.orientation(userColor);
        board.position(game.fen());

        if (userColor === "black") {
            autoPlayOpponentMove();
        }

        updateStatus();
    }

    function updateStatus(msg) {
  const statusText = msg || `Move ${currentIndex + 1} of ${pgnMoves.length}`;
  document.getElementById('status').textContent = statusText;

  // Update PGN up to and including last user move (for the left box)
  const movesUpToNow = pgnMoves.slice(0, currentIndex);
  const pgnGame = new Chess();
  movesUpToNow.forEach(m => pgnGame.move(m));
  currentPgnSoFar = pgnGame.pgn(); // Used for logging purposes
  // Note: We don't update the #stats-prev box here. Only on correct answers.

  // If there‚Äôs a move left for the user to make, update "current question" stats box
  if (currentIndex < pgnMoves.length) {
    const fen = game.fen();
    const expectedMove = pgnMoves[currentIndex];
    const key = getQuestionKey(fen, expectedMove);
    const stats = getStatsByKey(key, pgnId, userColor);

// Determine last move in PGN to label the opponent's move context
const fullHistory = game.history({ verbose: true });
const lastMove = fullHistory.length > 0 ? fullHistory[fullHistory.length - 1] : null;

document.getElementById('stats-box').innerHTML = formatStats(stats, {
  lastMove: lastMove // raw move object
});

  }

  moveStartTime = Date.now();
}

function onDrop(source, target) {
  const fenBeforeMove = game.fen(); // board before player moves
  const expectedMove = pgnMoves[currentIndex];
  const questionKey = getQuestionKey(fenBeforeMove, expectedMove);

  const move = game.move({ from: source, to: target, promotion: 'q' });
  if (move === null) return 'snapback';

  const timeTaken = (Date.now() - moveStartTime) / 1000;
  const correct = (move.san === expectedMove);

  // Always update live stats (right box) even if user was wrong
  recordAttempt(fenBeforeMove, correct, timeTaken, currentPgnSoFar, pgnId, userColor, expectedMove);
  const stats = getStatsByKey(questionKey, pgnId, userColor);
  document.getElementById('stats-box').innerHTML = formatStats(stats, {
    lastMove: game.history({ verbose: true }).slice(-1)[0]?.san || "start"
  });

  if (correct) {
    // Show previous question's stats (left box) only on correct
    const prevStats = getStatsByKey(questionKey, pgnId, userColor);
    // Capture full PGN with user's move included for left box
    const movesUpToNow = pgnMoves.slice(0, currentIndex + 1); // includes their latest move
    const fullMoveGame = new Chess();
    movesUpToNow.forEach(m => fullMoveGame.move(m));
    const fullPgnSoFar = fullMoveGame.pgn();

    document.getElementById('stats-prev').innerHTML = formatStats(prevStats, {
    pgn: fullPgnSoFar
    });


    currentIndex++;
    updateStatus();

    if (currentIndex < pgnMoves.length) {
      const turn = game.turn();
      const expectedColor = userColor === "white" ? "b" : "w";
      if (turn === expectedColor) {
        setTimeout(() => {
          autoPlayOpponentMove();
        }, 300);
      }
    } else {
      updateStatus("üéâ Complete! Great job.");
    }

    lastQuestionKey = questionKey;

  } else {
    game.undo(); // rollback board
    updateStatus(`‚ùå Incorrect. Expected: ${expectedMove}`);
    return 'snapback';
  }
}

function autoPlayOpponentMove() {
  if (currentIndex >= pgnMoves.length) return;

  const move = pgnMoves[currentIndex];
  game.move(move);
  board.position(game.fen());
  currentIndex++;

  // Update "current question" stats + show opponent move context
  if (currentIndex < pgnMoves.length) {
    const fen = game.fen();
    const nextMove = pgnMoves[currentIndex];
    const key = getQuestionKey(fen, nextMove);
    const stats = getStatsByKey(key, pgnId, userColor);
    document.getElementById('stats-box').innerHTML = formatStats(stats, {
      lastMove: {"color": userColor, "san": move} // opponent move that just happened
    });
  }
}


    function onSnapEnd() {
      board.position(game.fen());
    }

    board = Chessboard('board', {
      draggable: true,
      position: 'start',
      onDrop: onDrop,
      onSnapEnd: onSnapEnd
    });
  </script>


</body>
</html>
